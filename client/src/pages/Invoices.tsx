import { useState, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Search, Filter, MoreHorizontal, DollarSign, Calendar, FileText, Download, Plus, Send, Edit, CheckCircle, AlertTriangle, Trash2, Archive, FileDown, RefreshCw, ArrowLeft, Eye } from "lucide-react";
import { insertInvoiceSchema, type Invoice } from "@shared/schema";
import { useLocation, Link } from "wouter";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { z } from "zod";
import Sidebar from "@/components/sidebar";
import MobileNav from "@/components/mobile-nav";
import { useResponsive } from "@/hooks/useResponsive";

const invoiceFormSchema = z.object({
  contractId: z.number().optional(), // Made optional - contracts are just for auto-fill
  clientName: z.string().min(1, "Client name is required"),
  clientEmail: z.string().optional().refine((email) => {
    if (!email || email.trim() === '') return true;
    return email.includes('@');
  }, "Please enter a valid email address"),
  clientAddress: z.string().optional(),
  venueAddress: z.string().optional(),
  amount: z.string().min(1, "Amount is required").refine((val) => {
    const num = parseFloat(val);
    return !isNaN(num) && num > 0;
  }, "Amount must be a valid number greater than 0"),
  dueDate: z.string().min(1, "Due date is required"),
  performanceDate: z.string().optional(),
  performanceFee: z.string().optional(),
  depositPaid: z.string().optional(),
});

export default function Invoices() {
  const { toast } = useToast();
  const [location] = useLocation();
  const [searchQuery, setSearchQuery] = useState("");
  const [statusFilter, setStatusFilter] = useState("all");
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingInvoice, setEditingInvoice] = useState<Invoice | null>(null);
  const [editAndResendMode, setEditAndResendMode] = useState(false);
  const [selectedInvoices, setSelectedInvoices] = useState<number[]>([]);
  const [bulkActionLoading, setBulkActionLoading] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const { isDesktop } = useResponsive();

  // Check for URL parameters to auto-open dialog
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const createNew = params.get('create');
    if (createNew === 'true') {
      setIsDialogOpen(true);
    }
  }, [location]);

  const { data: invoices = [], isLoading } = useQuery({
    queryKey: ['/api/invoices'],
  });

  const { data: contracts = [] } = useQuery({
    queryKey: ['/api/contracts'],
  });

  const { data: userSettings } = useQuery({
    queryKey: ['/api/settings'],
  });

  const form = useForm<z.infer<typeof invoiceFormSchema>>({
    resolver: zodResolver(invoiceFormSchema),
    defaultValues: {
      contractId: undefined, // Optional contract selection
      clientName: "", 
      clientEmail: "",
      clientAddress: "",
      venueAddress: "",
      amount: "",
      dueDate: "",
      performanceDate: "",
      performanceFee: "",
      depositPaid: "",
    },
  });

  // Auto-set due date (invoice numbers are now auto-generated by backend)
  useEffect(() => {
    // Set due date to 30 days from now
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 30);
    form.setValue("dueDate", dueDate.toISOString().split('T')[0]);
  }, [form]);

  // Watch contract ID changes
  const selectedContractId = form.watch("contractId");

  // Auto-fill fields when contract is selected (for convenience)
  // Only auto-fill when user explicitly selects a contract (not when form first loads)
  const [contractHasBeenSelected, setContractHasBeenSelected] = useState(false);
  
  useEffect(() => {
    // Only auto-fill if a contract is explicitly selected AND we have contracts loaded
    if (selectedContractId && contracts.length > 0 && contractHasBeenSelected) {
      const selectedContract = contracts.find((c: any) => c.id === selectedContractId);
      if (selectedContract) {
        // Only fill empty fields to preserve user edits
        if (!form.getValues("clientName")) {
          form.setValue("clientName", selectedContract.clientName);
        }
        if (!form.getValues("clientEmail")) {
          form.setValue("clientEmail", selectedContract.clientEmail || "");
        }
        if (!form.getValues("venueAddress")) {
          form.setValue("venueAddress", selectedContract.venue || "");
        }
        if (!form.getValues("performanceDate") && selectedContract.eventDate) {
          form.setValue("performanceDate", new Date(selectedContract.eventDate).toISOString().split('T')[0]);
        }
        if (!form.getValues("amount") && selectedContract.fee) {
          // Set the performance fee and calculate amount due (fee minus any deposit)
          const fee = Number(selectedContract.fee);
          const deposit = Number(selectedContract.deposit) || 0;
          const amountDue = fee - deposit;
          form.setValue("amount", amountDue.toString());
          // Store fee and deposit for backend
          form.setValue("performanceFee", fee.toString());
          form.setValue("depositPaid", deposit.toString());
        }
      }
    }
  }, [selectedContractId, contracts, form, contractHasBeenSelected]);

  // Auto-fill business address and phone from settings
  useEffect(() => {
    if (userSettings?.businessAddress) {
      form.setValue("businessAddress", userSettings.businessAddress);
    }
    if (userSettings?.phone) {
      form.setValue("businessPhone", userSettings.phone);
    }
  }, [userSettings, form]);

  const createInvoiceMutation = useMutation({
    mutationFn: async (data: any) => {
      console.log("ðŸ”¥ Frontend: Making invoice creation request");
      console.log("ðŸ”¥ Frontend: Request data:", JSON.stringify(data, null, 2));
      console.log("ðŸ”¥ Frontend: Request URL:", '/api/invoices');
      
      // Use fetch directly to ensure we hit the priority route
      const response = await fetch('/api/invoices', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include', // Important for session handling
        body: JSON.stringify(data),
      });
      
      console.log("ðŸ”¥ Frontend: Response status:", response.status);
      console.log("ðŸ”¥ Frontend: Response ok:", response.ok);
      
      if (!response.ok) {
        const errorData = await response.text();
        console.error("ðŸ”¥ Frontend: Error response:", errorData);
        throw new Error(errorData || 'Failed to create invoice');
      }
      
      const result = await response.json();
      console.log("ðŸ”¥ Frontend: Success response:", result);
      return result;
    },
    onSuccess: (data) => {
      console.log("ðŸ”¥ Frontend: Mutation success:", data);
      queryClient.invalidateQueries({ queryKey: ['/api/invoices'] });
      form.reset();
      setIsDialogOpen(false);
      setEditingInvoice(null);
      toast({
        title: "Success",
        description: "Invoice created successfully!",
      });
    },
    onError: (error: any) => {
      console.error("ðŸ”¥ Frontend: Mutation error:", error);
      console.error("ðŸ”¥ Frontend: Error message:", error.message);
      console.error("ðŸ”¥ Frontend: Error stack:", error.stack);
      
      // Show specific error message if available
      const errorMessage = error.message || "Failed to create invoice. Please try again.";
      
      toast({
        title: "Error Creating Invoice",
        description: errorMessage,
        variant: "destructive",
      });
    },
  });

  const updateInvoiceMutation = useMutation({
    mutationFn: async ({ id, data }: { id: number; data: any }) => {
      console.log("Updating invoice with data:", JSON.stringify(data, null, 2));
      const response = await fetch(`/api/invoices/${id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(data),
      });
      if (!response.ok) {
        const errorData = await response.json();
        console.error("API Error Response:", errorData);
        throw new Error(errorData.message || 'Failed to update invoice');
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/invoices'] });
      form.reset();
      setIsDialogOpen(false);
      setEditingInvoice(null);
      
      // If in edit & resend mode, automatically send the invoice
      if (editAndResendMode && editingInvoice) {
        setEditAndResendMode(false);
        setTimeout(() => {
          sendInvoiceMutation.mutate(editingInvoice);
        }, 500);
        toast({
          title: "Success",
          description: "Invoice updated and being sent...",
        });
      } else {
        toast({
          title: "Success",
          description: "Invoice updated successfully!",
        });
      }
    },
    onError: (error: any) => {
      console.error("Update invoice error:", error);
      setEditAndResendMode(false);
      
      // Show specific error message if available
      const errorMessage = error.message || "Failed to update invoice. Please try again.";
      
      toast({
        title: "Error Updating Invoice",
        description: errorMessage,
        variant: "destructive",
      });
    },
  });

  const sendInvoiceMutation = useMutation({
    mutationFn: async (invoice: Invoice) => {
      const response = await fetch(`/api/invoices/${invoice.id}/send-email`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });
      if (!response.ok) {
        throw new Error('Failed to send invoice');
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/invoices'] });
      toast({
        title: "Success",
        description: "Invoice sent successfully!",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to send invoice",
        variant: "destructive",
      });
    },
  });

  const handleEditInvoice = (invoice: Invoice) => {
    setEditingInvoice(invoice);
    setEditAndResendMode(false);
    // Pre-fill form with invoice data
    form.reset({
      contractId: invoice.contractId || undefined,
      clientName: invoice.clientName,
      clientEmail: invoice.clientEmail || "",
      clientAddress: invoice.clientAddress || "",
      venueAddress: invoice.venueAddress || "",
      amount: invoice.amount.toString(),
      dueDate: new Date(invoice.dueDate).toISOString().split('T')[0],
      performanceDate: invoice.performanceDate ? new Date(invoice.performanceDate).toISOString().split('T')[0] : "",
      performanceFee: invoice.performanceFee || "",
      depositPaid: invoice.depositPaid || "",
    });
    setIsDialogOpen(true);
  };

  const handleEditAndResend = (invoice: Invoice) => {
    setEditingInvoice(invoice);
    setEditAndResendMode(true);
    // Pre-fill form with invoice data
    form.reset({
      contractId: invoice.contractId || undefined,
      clientName: invoice.clientName,
      clientEmail: invoice.clientEmail || "",
      clientAddress: invoice.clientAddress || "",
      venueAddress: invoice.venueAddress || "",
      amount: invoice.amount.toString(),
      dueDate: new Date(invoice.dueDate).toISOString().split('T')[0],
      performanceDate: invoice.performanceDate ? new Date(invoice.performanceDate).toISOString().split('T')[0] : "",
      performanceFee: invoice.performanceFee || "",
      depositPaid: invoice.depositPaid || "",
    });
    setIsDialogOpen(true);
  };

  const onSubmit = (data: z.infer<typeof invoiceFormSchema>) => {
    console.log("ðŸ”¥ Frontend: Form submission data:", JSON.stringify(data, null, 2));
    console.log("ðŸ”¥ Frontend: Selected contract ID:", selectedContractId);
    
    // Debug: Log form values directly
    console.log("ðŸ”¥ Frontend: Form values debug:", {
      clientName: form.getValues("clientName"),
      amount: form.getValues("amount"),
      dueDate: form.getValues("dueDate"),
      clientEmail: form.getValues("clientEmail"),
    });
    
    // Client-side validation with user-friendly prompts
    const validationIssues = [];
    
    if (!data.clientName || !data.clientName.trim()) {
      validationIssues.push("Client name cannot be empty");
    }
    
    if (!data.amount || !data.amount.trim()) {
      validationIssues.push("Amount is required");
    } else {
      const amount = parseFloat(data.amount);
      if (isNaN(amount) || amount <= 0) {
        validationIssues.push("Amount must be a valid number greater than 0");
      }
    }
    
    if (!data.dueDate) {
      validationIssues.push("Due date is required");
    }
    
    if (data.clientEmail && data.clientEmail.trim() && !data.clientEmail.includes('@')) {
      validationIssues.push("Please enter a valid email address");
    }
    
    // Show validation issues as a prompt instead of failing
    if (validationIssues.length > 0) {
      console.log("ðŸ”¥ Frontend: Validation issues:", validationIssues);
      toast({
        title: "Please fix the following issues:",
        description: validationIssues.join(", "),
        variant: "destructive",
      });
      return; // Don't submit the form
    }
    
    // Warn if no client email provided
    if (!data.clientEmail || !data.clientEmail.trim()) {
      toast({
        title: "Note",
        description: "No client email provided. Invoice will be created but cannot be sent automatically.",
      });
    }
    
    // Prepare data for backend - ensure we have all required fields
    const formattedData = {
      contractId: data.contractId || null, // Convert undefined to null for optional integer
      clientName: data.clientName?.trim() || "",
      clientEmail: data.clientEmail?.trim() || null,
      clientAddress: data.clientAddress?.trim() || null,
      venueAddress: data.venueAddress?.trim() || null,
      amount: data.amount || "",
      dueDate: data.dueDate || "",
      performanceDate: data.performanceDate || null,
      performanceFee: data.performanceFee || null,
      depositPaid: data.depositPaid || null,
    };
    
    console.log("ðŸ”¥ Frontend: Formatted data for backend:", JSON.stringify(formattedData, null, 2));
    
    if (editingInvoice) {
      updateInvoiceMutation.mutate({
        id: editingInvoice.id,
        data: formattedData,
      });
    } else {
      createInvoiceMutation.mutate(formattedData);
    }
  };

  const filteredInvoices = invoices.filter((invoice: Invoice) => {
    const matchesSearch = invoice.clientName.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         invoice.invoiceNumber.toLowerCase().includes(searchQuery.toLowerCase());
    const matchesStatus = statusFilter === 'all' || invoice.status === statusFilter;
    return matchesSearch && matchesStatus;
  });

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'draft': return 'bg-gray-100 text-gray-800';
      case 'sent': return 'bg-blue-100 text-blue-800';
      case 'paid': return 'bg-green-100 text-green-800';
      case 'overdue': return 'bg-red-100 text-red-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const statusOptions = [
    { value: 'all', label: 'All Status' },
    { value: 'draft', label: 'Draft' },
    { value: 'sent', label: 'Sent' },
    { value: 'paid', label: 'Paid' },
    { value: 'overdue', label: 'Overdue' },
  ];

  if (isLoading) {
    return (
      <div className="flex h-screen">
        {isDesktop ? (
          <Sidebar />
        ) : (
          <MobileNav sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
        )}
        <div className={`flex-1 ${isDesktop ? 'ml-64' : ''}`}>
          <div className="p-6">
            <div className="animate-pulse">
              <div className="h-8 bg-gray-200 rounded w-1/4 mb-4"></div>
              <div className="space-y-3">
                <div className="h-4 bg-gray-200 rounded"></div>
                <div className="h-4 bg-gray-200 rounded w-5/6"></div>
                <div className="h-4 bg-gray-200 rounded w-4/6"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-screen">
      {isDesktop ? (
        <Sidebar />
      ) : (
        <MobileNav sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
      )}
      <div className={`flex-1 ${isDesktop ? 'ml-64' : ''}`}>
        <div className="p-6">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h1 className="text-2xl font-bold text-gray-900">Invoices</h1>
              <p className="text-gray-600">Manage your invoices and track payments</p>
            </div>
            <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
              <DialogTrigger asChild>
                <Button>
                  <Plus className="h-4 w-4 mr-2" />
                  New Invoice
                </Button>
              </DialogTrigger>
              <DialogContent className="max-w-2xl">
                <DialogHeader>
                  <DialogTitle>
                    {editingInvoice ? 'Edit Invoice' : 'Create New Invoice'}
                  </DialogTitle>
                </DialogHeader>
                <Form {...form}>
                  <form onSubmit={form.handleSubmit(onSubmit, (errors) => {
                    console.log("ðŸ”¥ Frontend: Form validation errors:", errors);
                  })} className="space-y-4">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <FormField
                        control={form.control}
                        name="contractId"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Contract (optional - for auto-fill)</FormLabel>
                            <Select
                              value={field.value?.toString() || ""}
                              onValueChange={(value) => {
                                const numValue = value ? Number(value) : undefined;
                                field.onChange(numValue);
                                setContractHasBeenSelected(true);
                              }}
                            >
                              <FormControl>
                                <SelectTrigger>
                                  <SelectValue placeholder="Choose a contract to auto-fill fields" />
                                </SelectTrigger>
                              </FormControl>
                              <SelectContent>
                                {contracts.map((contract: any) => (
                                  <SelectItem key={contract.id} value={contract.id.toString()}>
                                    {contract.clientName} - {contract.venue}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <div></div>
                      <FormField
                        control={form.control}
                        name="clientName"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Client Name *</FormLabel>
                            <FormControl>
                              <Input placeholder="Enter client name" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="clientEmail"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Client Email</FormLabel>
                            <FormControl>
                              <Input placeholder="client@example.com" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="clientAddress"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Client Address</FormLabel>
                            <FormControl>
                              <Input placeholder="Client's billing address" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="venueAddress"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Venue Address</FormLabel>
                            <FormControl>
                              <Input placeholder="Performance venue address" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="amount"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Amount *</FormLabel>
                            <FormControl>
                              <Input placeholder="0.00" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="dueDate"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Due Date *</FormLabel>
                            <FormControl>
                              <Input type="date" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="performanceDate"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Performance Date</FormLabel>
                            <FormControl>
                              <Input type="date" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="performanceFee"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Performance Fee</FormLabel>
                            <FormControl>
                              <Input placeholder="0.00" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <FormField
                        control={form.control}
                        name="depositPaid"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Deposit Paid</FormLabel>
                            <FormControl>
                              <Input placeholder="0.00" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>
                    <div className="flex justify-end space-x-2">
                      <Button type="button" variant="outline" onClick={() => setIsDialogOpen(false)}>
                        Cancel
                      </Button>
                      <Button type="submit" disabled={createInvoiceMutation.isPending || updateInvoiceMutation.isPending}>
                        {editingInvoice ? 'Update Invoice' : 'Create Invoice'}
                      </Button>
                    </div>
                  </form>
                </Form>
              </DialogContent>
            </Dialog>
          </div>

          {/* Search and Filter */}
          <div className="flex items-center justify-between mb-6">
            <div className="relative flex-1 max-w-md">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              <Input
                placeholder="Search invoices..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10"
              />
            </div>
            <div className="flex items-center space-x-2">
              <Filter className="h-4 w-4 text-gray-400" />
              <Select value={statusFilter} onValueChange={setStatusFilter}>
                <SelectTrigger className="w-40">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {statusOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Invoices List */}
          <div className="space-y-4">
            {filteredInvoices.length === 0 ? (
              <div className="text-center py-12">
                <FileText className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-semibold text-gray-900 mb-2">No invoices found</h3>
                <p className="text-gray-600">
                  {searchQuery || statusFilter !== 'all' 
                    ? 'Try adjusting your search or filter criteria'
                    : 'Create your first invoice to get started'
                  }
                </p>
              </div>
            ) : (
              filteredInvoices.map((invoice: Invoice) => (
                <Card key={invoice.id} className="hover:shadow-md transition-shadow">
                  <CardContent className="p-6">
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        <div className="flex items-center space-x-3 mb-2">
                          <h3 className="text-lg font-semibold text-gray-900">
                            {invoice.invoiceNumber}
                          </h3>
                          <Badge className={getStatusColor(invoice.status)}>
                            {invoice.status}
                          </Badge>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-600">
                          <div>
                            <span className="font-medium">Client:</span> {invoice.clientName}
                          </div>
                          <div>
                            <span className="font-medium">Amount:</span> Â£{invoice.amount}
                          </div>
                          <div>
                            <span className="font-medium">Due:</span> {new Date(invoice.dueDate).toLocaleDateString()}
                          </div>
                          <div>
                            <span className="font-medium">Status:</span> {invoice.status}
                          </div>
                        </div>
                      </div>
                      <div className="flex items-center space-x-2">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => handleEditInvoice(invoice)}
                        >
                          <Edit className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => sendInvoiceMutation.mutate(invoice)}
                        >
                          <Send className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="sm"
                        >
                          <Download className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
}