import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { storage } from "./storage";
import OpenAI from "openai";

const app = express();

// Essential middleware setup
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Initialize separate OpenAI clients for different functions
const emailParsingAI = process.env.OPENAI_EMAIL_PARSING_KEY ? new OpenAI({ apiKey: process.env.OPENAI_EMAIL_PARSING_KEY }) : null;
const instrumentMappingAI = process.env.OPENAI_INSTRUMENT_MAPPING_KEY ? new OpenAI({ apiKey: process.env.OPENAI_INSTRUMENT_MAPPING_KEY }) : null;
const conflictResolutionAI = process.env.OPENAI_CONFLICT_RESOLUTION_KEY ? new OpenAI({ apiKey: process.env.OPENAI_CONFLICT_RESOLUTION_KEY }) : null;
const supportChatAI = process.env.OPENAI_SUPPORT_CHAT_KEY ? new OpenAI({ apiKey: process.env.OPENAI_SUPPORT_CHAT_KEY }) : null;

console.log('ü§ñ Email Parsing AI initialized:', !!emailParsingAI);
console.log('ü§ñ Instrument Mapping AI initialized:', !!instrumentMappingAI);
console.log('ü§ñ Conflict Resolution AI initialized:', !!conflictResolutionAI);
console.log('ü§ñ Support Chat AI initialized:', !!supportChatAI);

// AI-Enhanced Email Parsing Function
async function parseEmailWithAI(emailBody: string, subject: string): Promise<{
  eventDate: string | null;
  eventTime: string | null;
  venue: string | null;
  eventType: string | null;
  gigType: string | null;
  clientPhone: string | null;
  estimatedValue: string | null;
  applyNowLink: string | null;
}> {
  if (!emailParsingAI) {
    return { eventDate: null, eventTime: null, venue: null, eventType: null, gigType: null, clientPhone: null, estimatedValue: null, applyNowLink: null };
  }

  try {
    const currentYear = new Date().getFullYear();
    const currentDate = new Date();
    
    // Pre-process the email body to replace "next year" with the actual year
    const processedBody = emailBody.replace(/next year/gi, `${currentYear + 1}`);
    const processedSubject = subject.replace(/next year/gi, `${currentYear + 1}`);
    
    const prompt = `Parse this email enquiry for a musician/performer and extract structured information. Return JSON only.

Email Subject: "${processedSubject}"
Email Body: "${processedBody}"

CURRENT CONTEXT:
- Today's date: ${new Date().toISOString().split('T')[0]}
- Current year: ${currentYear}
- Current month: ${currentDate.getMonth() + 1}
- Current day: ${currentDate.getDate()}

CRITICAL INSTRUCTIONS:
1. Find the ACTUAL EVENT DATE - look for "Sunday 24 Aug 2025", "Aug 24", "24 Aug 2025" etc. NOT email send dates like "13 Jul 2025 at 15:42"
2. RELATIVE DATE PARSING: For relative dates like "next Saturday", "next Friday", calculate from today's date (${new Date().toISOString().split('T')[0]}) within the current year (${currentYear}) unless explicitly stated otherwise.
2. Find the ACTUAL VENUE - look for location names like "Bognor Regis", "Brighton", city names, NOT email addresses or timestamps
3. Find BUDGET/PRICE information - look for "¬£260-¬£450", "¬£300", price ranges in the email content
4. ENCORE DETECTION: Look for "Apply Now" buttons or links - these are typically from Encore booking platform
5. ENCORE URL FORMAT: For Encore emails, extract the job ID from the subject line (e.g., [QuH57], [LM16k], [yij5S]) and create URL: https://encoremusicians.com/jobs/{jobId}?utm_source=transactional&utm_medium=email&utm_campaign=newJobAlert&utm_content=ApplyNow. Example: Subject contains [QuH57] ‚Üí URL: https://encoremusicians.com/jobs/QuH57?utm_source=transactional&utm_medium=email&utm_campaign=newJobAlert&utm_content=ApplyNow. NEVER use /job/apply format as it leads to 404 errors.
6. REDIRECT URLS: If you find a complete redirect URL starting with https://rbtin183.r.eu-west-1.awstrack.me/, use that instead of constructing a URL.

Extract:
- eventDate: The actual event/performance date in YYYY-MM-DD format (e.g., "Sunday 24 Aug 2025" = "2025-08-24", "14th July 2026" = "2026-07-14")
- eventTime: Start time if mentioned (e.g., "1:00pm - 3:00pm", "7:30pm")
- venue: Location/venue name including city/area (e.g., "Bognor Regis", "Brighton Hotel", "London venue")
- eventType: wedding, birthday, corporate, party, celebration, private event, etc.
- gigType: sax, saxophone, jazz, piano, guitar, dj, band, violin, drums, etc.
- clientPhone: UK phone number if mentioned
- estimatedValue: Budget/price range if mentioned (e.g., "¬£260-¬£450", "¬£300", "budget of ¬£500")
- applyNowLink: If this is an Encore email, look for the job ID in square brackets in the subject line (e.g., [QuH57], [LM16k], [yij5S]) and create this exact URL format: https://encoremusicians.com/jobs/{jobId}?utm_source=transactional&utm_medium=email&utm_campaign=newJobAlert&utm_content=ApplyNow. For example, if subject contains [QuH57], return: https://encoremusicians.com/jobs/QuH57?utm_source=transactional&utm_medium=email&utm_campaign=newJobAlert&utm_content=ApplyNow. If you find a complete redirect URL starting with https://rbtin183.r.eu-west-1.awstrack.me/, use that instead. Return null if not an Encore email.

Return valid JSON only:`;

    const response = await emailParsingAI.chat.completions.create({
      model: "gpt-3.5-turbo", // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
      messages: [
        {
          role: "system",
          content: "You are a professional assistant that extracts structured information from emails. Always return only valid JSON without any additional text or explanation."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 500,
      temperature: 0
    });

    const content = response.choices[0]?.message?.content;
    
    if (!content) {
      console.log('‚ö†Ô∏è No content from OpenAI response');
      return { eventDate: null, eventTime: null, venue: null, eventType: null, gigType: null, clientPhone: null, estimatedValue: null, applyNowLink: null };
    }

    try {
      const parsed = JSON.parse(content);
      console.log('‚úÖ Email parsed successfully:', parsed);
      return parsed;
    } catch (parseError) {
      console.error('‚ùå Error parsing JSON from OpenAI:', parseError);
      console.log('Raw content:', content);
      return { eventDate: null, eventTime: null, venue: null, eventType: null, gigType: null, clientPhone: null, estimatedValue: null, applyNowLink: null };
    }
  } catch (error) {
    console.error('‚ùå Error calling OpenAI:', error);
    return { eventDate: null, eventTime: null, venue: null, eventType: null, gigType: null, clientPhone: null, estimatedValue: null, applyNowLink: null };
  }
}

// Conflict detection function (without conflict resolution AI for now)
async function detectConflicts(eventDate: string, eventTime: string, excludeId: string | null = null): Promise<{ hasConflict: boolean, conflictDetails: any[] }> {
  if (!eventDate) {
    return { hasConflict: false, conflictDetails: [] };
  }

  try {
    // Get all enquiries, bookings, and confirmed enquiries for the same date
    const allEnquiries = await storage.getAllEnquiries();
    const allBookings = await storage.getAllBookings();
    
    const conflicts = [];
    
    // Check enquiries
    for (const enquiry of allEnquiries) {
      if (enquiry.id === excludeId) continue;
      
      if (enquiry.eventDate === eventDate) {
        conflicts.push({
          type: 'enquiry',
          id: enquiry.id,
          clientName: enquiry.clientName,
          eventTime: enquiry.eventTime,
          venue: enquiry.venue,
          status: enquiry.status
        });
      }
    }
    
    // Check bookings
    for (const booking of allBookings) {
      if (booking.id === excludeId) continue;
      
      if (booking.eventDate === eventDate) {
        conflicts.push({
          type: 'booking',
          id: booking.id,
          clientName: booking.clientName,
          eventTime: booking.eventTime,
          venue: booking.venue,
          status: 'confirmed'
        });
      }
    }
    
    return {
      hasConflict: conflicts.length > 0,
      conflictDetails: conflicts
    };
  } catch (error) {
    console.error('‚ùå Error detecting conflicts:', error);
    return { hasConflict: false, conflictDetails: [] };
  }
}

// Support Chat Handler
app.post('/api/support-chat', async (req: Request, res: Response) => {
  try {
    const { message } = req.body;
    
    if (!supportChatAI) {
      return res.status(500).json({ error: 'Support chat AI not configured' });
    }

    const response = await supportChatAI.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: `You are a helpful support assistant for MusoBuddy, a music business management platform. Help users with:

CORE FEATURES:
- Email forwarding: leads@musobuddy.com automatically creates enquiries
- Bookings: Manage enquiries from potential clients
- Contracts: Create and send digital contracts for signing
- Invoices: Generate and send professional invoices
- Calendar: View upcoming gigs and manage availability
- Address Book: Store client contact information
- Settings: Configure business details and preferences

COMMON ISSUES:
- Email forwarding: Emails sent to leads@musobuddy.com create enquiries automatically
- Contract signing: Clients receive email with "Sign Contract Online" button
- Invoice creation: Can be created independently or from existing contracts
- Calendar sync: Export .ics files work with Google Calendar, Apple Calendar, Outlook

Keep responses concise and helpful. If you need more information, ask specific questions.`
        },
        {
          role: "user",
          content: message
        }
      ],
      max_tokens: 500,
      temperature: 0.7
    });

    const content = response.choices[0]?.message?.content;
    
    if (!content) {
      return res.status(500).json({ error: 'No response from support chat AI' });
    }

    res.json({ response: content });
  } catch (error) {
    console.error('‚ùå Support chat error:', error);
    res.status(500).json({ error: 'Error processing support chat request' });
  }
});

// Enhanced Mailgun webhook handler (ultra-safe implementation)
app.use('/api/webhook/mailgun', async (req: Request, res: Response) => {
  console.log('üî• MAILGUN WEBHOOK CALLED');
  console.log('Request method:', req.method);
  console.log('Request headers:', req.headers);
  console.log('Request body:', req.body);
  
  try {
    // Handle preflight requests
    if (req.method === 'OPTIONS') {
      res.set('Access-Control-Allow-Origin', '*');
      res.set('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
      res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      return res.status(200).send();
    }

    if (req.method !== 'POST') {
      return res.status(405).json({ error: 'Method not allowed' });
    }

    // Extract email data from Mailgun webhook
    const { sender, subject, 'body-plain': bodyPlain, 'body-html': bodyHtml } = req.body;
    
    console.log('üìß Webhook data:', {
      sender,
      subject,
      bodyPlain: bodyPlain ? bodyPlain.substring(0, 200) + '...' : 'No plain body',
      bodyHtml: bodyHtml ? 'HTML body present' : 'No HTML body'
    });

    // Extract client information
    let clientName = 'Unknown';
    let clientEmail = 'unknown@example.com';
    
    if (sender && sender.includes('<') && sender.includes('>')) {
      // Format: "Name <email@domain.com>"
      const nameMatch = sender.match(/^([^<]+)</);
      const emailMatch = sender.match(/<([^>]+)>/);
      
      if (nameMatch) clientName = nameMatch[1].trim();
      if (emailMatch) clientEmail = emailMatch[1].trim();
    } else if (sender) {
      // Just email address
      clientEmail = sender;
      clientName = sender.split('@')[0];
    }

    // Use plain text body for content, fallback to HTML
    const emailBody = bodyPlain || bodyHtml || 'No message content';
    
    // Parse email with AI for structured data
    const aiParsedData = await parseEmailWithAI(emailBody, subject || 'No subject');
    
    // Detect conflicts
    const conflicts = await detectConflicts(aiParsedData.eventDate, aiParsedData.eventTime, null);
    
    // Create enquiry with ultra-safe date handling
    const enquiryData = {
      clientName,
      clientEmail,
      clientPhone: aiParsedData.clientPhone || null,
      eventDate: aiParsedData.eventDate || null,
      eventTime: aiParsedData.eventTime || null,
      venue: aiParsedData.venue || null,
      eventType: aiParsedData.eventType || null,
      gigType: aiParsedData.gigType || null,
      estimatedValue: aiParsedData.estimatedValue || null,
      notes: `Email Subject: ${subject || 'No subject'}\n\nEmail Body:\n${emailBody}`,
      status: 'new' as const,
      source: 'email',
      applyNowLink: aiParsedData.applyNowLink || null,
      hasConflict: conflicts.hasConflict,
      conflictDetails: conflicts.conflictDetails
    };

    console.log('üìù Creating enquiry:', enquiryData);
    
    const enquiry = await storage.createEnquiry(enquiryData);
    
    console.log('‚úÖ Enquiry created successfully:', enquiry);
    
    res.status(200).json({ 
      success: true, 
      enquiry: enquiry,
      message: 'Enquiry created successfully'
    });
  } catch (error) {
    console.error('‚ùå Webhook error:', error);
    res.status(500).json({ error: 'Error processing webhook' });
  }
});

// Handle webhook POST requests before main routes
app.post('/api/webhook/mailgun-direct', async (req: Request, res: Response) => {
  console.log('üî• DIRECT MAILGUN WEBHOOK CALLED');
  console.log('Request body:', req.body);
  
  try {
    // Extract email data
    const { sender, subject, 'body-plain': bodyPlain } = req.body;
    
    // Simple enquiry creation (bypassing all complex processing)
    const enquiryData = {
      clientName: sender?.split('@')[0] || 'Unknown',
      clientEmail: sender || 'unknown@example.com',
      clientPhone: null,
      eventDate: null,
      eventTime: null,
      venue: null,
      eventType: null,
      gigType: null,
      estimatedValue: null,
      notes: `Subject: ${subject || 'No subject'}\n\nBody:\n${bodyPlain || 'No content'}`,
      status: 'new' as const,
      source: 'email',
      applyNowLink: null,
      hasConflict: false,
      conflictDetails: []
    };

    const enquiry = await storage.createEnquiry(enquiryData);
    
    console.log('‚úÖ Direct webhook enquiry created:', enquiry);
    
    res.status(200).json({ 
      success: true, 
      enquiry: enquiry,
      message: 'Direct webhook enquiry created successfully'
    });
  } catch (error) {
    console.error('‚ùå Direct webhook error:', error);
    res.status(500).json({ error: 'Error processing direct webhook' });
  }
});

// Register all other routes
(async () => {
  const server = await registerRoutes(app);
  
  // In production, serve the built frontend
  if (process.env.NODE_ENV === "production") {
    console.log('üöÄ Starting production server...');
    await serveStatic(app);
  } else {
    console.log('üîß Starting development server...');
    await setupVite(app, server);
  }
})();