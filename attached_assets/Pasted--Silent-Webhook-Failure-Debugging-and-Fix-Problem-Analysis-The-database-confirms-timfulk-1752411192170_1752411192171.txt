# Silent Webhook Failure - Debugging and Fix

## Problem Analysis

The database confirms:
- `timfulker@gmail.com` → Creates enquiry #331 successfully
- `timfulkermusic@gmail.com` → **NO database records** (silent failure)

This means the webhook receives the email but fails **before** calling `storage.createEnquiry()`.

## Potential Failure Points in server/index.ts

### 1. Email Regex Extraction Failure
```javascript
// Line ~65 in webhook handler
const emailMatch = from.match(/[\w.-]+@[\w.-]+\.\w+/);
const clientEmail = emailMatch ? emailMatch[0] : from;
```

**Issue**: The regex might not match `timfulkermusic@gmail.com` properly if the email comes with additional formatting.

### 2. Silent Exception in Enquiry Creation
```javascript
const newEnquiry = await storage.createEnquiry(enquiry);
```

**Issue**: If this throws an exception, the current catch block might not be logging it properly.

### 3. Data Validation Failure
The enquiry object construction might be failing validation for specific email formats.

## Complete Debugging Solution

Replace the webhook handler in `server/index.ts` with this comprehensive debugging version:

```typescript
// COMPREHENSIVE DEBUG MAILGUN WEBHOOK
app.post('/api/webhook/mailgun', express.urlencoded({ extended: true }), async (req: Request, res: Response) => {
  const startTime = Date.now();
  const requestId = Math.random().toString(36).substring(7);
  
  console.log(`📧 [${requestId}] === WEBHOOK START ===`);
  console.log(`📧 [${requestId}] Timestamp:`, new Date().toISOString());
  console.log(`📧 [${requestId}] Headers:`, JSON.stringify(req.headers, null, 2));
  console.log(`📧 [${requestId}] Method:`, req.method);
  console.log(`📧 [${requestId}] URL:`, req.url);
  console.log(`📧 [${requestId}] Content-Type:`, req.headers['content-type']);
  
  try {
    // STEP 1: Log raw body data
    console.log(`📧 [${requestId}] === STEP 1: RAW DATA ===`);
    console.log(`📧 [${requestId}] Body keys:`, Object.keys(req.body || {}));
    console.log(`📧 [${requestId}] Body size:`, JSON.stringify(req.body || {}).length);
    console.log(`📧 [${requestId}] Full body:`, JSON.stringify(req.body, null, 2));
    
    if (Object.keys(req.body || {}).length === 0) {
      console.log(`⚠️ [${requestId}] CRITICAL: Empty body received`);
      return res.status(200).json({ 
        success: false, 
        error: 'Empty webhook body',
        requestId 
      });
    }
    
    // STEP 2: Extract email fields with detailed logging
    console.log(`📧 [${requestId}] === STEP 2: FIELD EXTRACTION ===`);
    
    const from = req.body.From || req.body.from || req.body.sender || '';
    const subject = req.body.Subject || req.body.subject || 'Email enquiry';
    const body = req.body['body-plain'] || req.body['stripped-text'] || req.body.text || '';
    
    console.log(`📧 [${requestId}] Raw From field:`, JSON.stringify(from));
    console.log(`📧 [${requestId}] Raw Subject field:`, JSON.stringify(subject));
    console.log(`📧 [${requestId}] Raw Body length:`, body.length);
    console.log(`📧 [${requestId}] Body preview:`, body.substring(0, 200));
    
    // STEP 3: Email extraction with detailed regex testing
    console.log(`📧 [${requestId}] === STEP 3: EMAIL EXTRACTION ===`);
    
    let clientEmail = '';
    let emailExtractionMethod = '';
    
    // Test the original regex
    const emailRegex = /[\w.-]+@[\w.-]+\.\w+/;
    const emailMatch = from.match(emailRegex);
    
    console.log(`📧 [${requestId}] Testing regex on:`, from);
    console.log(`📧 [${requestId}] Regex result:`, emailMatch);
    
    if (emailMatch) {
      clientEmail = emailMatch[0];
      emailExtractionMethod = 'regex_match';
    } else {
      // Fallback: try a more permissive regex
      const permissiveRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/;
      const permissiveMatch = from.match(permissiveRegex);
      
      console.log(`📧 [${requestId}] Permissive regex result:`, permissiveMatch);
      
      if (permissiveMatch) {
        clientEmail = permissiveMatch[0];
        emailExtractionMethod = 'permissive_regex';
      } else {
        clientEmail = from;
        emailExtractionMethod = 'fallback_raw';
      }
    }
    
    console.log(`📧 [${requestId}] Extracted email:`, clientEmail);
    console.log(`📧 [${requestId}] Extraction method:`, emailExtractionMethod);
    
    // STEP 4: Client name extraction with detailed logging
    console.log(`📧 [${requestId}] === STEP 4: NAME EXTRACTION ===`);
    
    let clientName = 'Unknown';
    let nameExtractionMethod = '';
    
    if (from.includes('<')) {
      const nameMatch = from.match(/^([^<]+)/);
      if (nameMatch) {
        clientName = nameMatch[1].trim().replace(/"/g, '');
        nameExtractionMethod = 'from_header_bracket';
      }
    } else if (clientEmail) {
      clientName = clientEmail.split('@')[0];
      nameExtractionMethod = 'email_prefix';
    }
    
    // Try to find name in body
    const bodyNameMatch = body.match(/(?:my name is|i'm|i am|this is)\s+([A-Za-z\s]{2,30}?)(?:\s+and|\s+I|\.|,|\n|$)/i);
    if (bodyNameMatch) {
      clientName = bodyNameMatch[1].trim();
      nameExtractionMethod = 'body_text';
    }
    
    console.log(`📧 [${requestId}] Extracted name:`, clientName);
    console.log(`📧 [${requestId}] Name extraction method:`, nameExtractionMethod);
    
    // STEP 5: Construct enquiry object with validation
    console.log(`📧 [${requestId}] === STEP 5: ENQUIRY CONSTRUCTION ===`);
    
    const enquiry = {
      userId: '43963086',
      title: subject || `Email enquiry from ${clientName}`,
      clientName,
      clientEmail,
      clientPhone: null,
      eventDate: null,
      eventTime: null,
      eventEndTime: null,
      performanceDuration: null,
      venue: null,
      eventType: null,
      gigType: null,
      estimatedValue: null,
      status: 'new' as const,
      notes: body || 'Email enquiry received',
      responseNeeded: true,
      lastContactedAt: null
    };
    
    console.log(`📧 [${requestId}] Enquiry object:`, JSON.stringify(enquiry, null, 2));
    
    // STEP 6: Validate required fields
    console.log(`📧 [${requestId}] === STEP 6: VALIDATION ===`);
    
    const validation = {
      hasUserId: !!enquiry.userId,
      hasTitle: !!enquiry.title,
      hasClientName: !!enquiry.clientName,
      hasStatus: !!enquiry.status,
      titleLength: enquiry.title.length,
      clientNameLength: enquiry.clientName.length
    };
    
    console.log(`📧 [${requestId}] Validation:`, validation);
    
    if (!enquiry.userId || !enquiry.title || !enquiry.clientName || !enquiry.status) {
      console.log(`❌ [${requestId}] VALIDATION FAILED - Missing required fields`);
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        validation,
        requestId
      });
    }
    
    // STEP 7: Database insertion with detailed error handling
    console.log(`📧 [${requestId}] === STEP 7: DATABASE INSERTION ===`);
    
    let newEnquiry;
    try {
      console.log(`📧 [${requestId}] Calling storage.createEnquiry...`);
      newEnquiry = await storage.createEnquiry(enquiry);
      console.log(`📧 [${requestId}] ✅ SUCCESS - Enquiry created:`, newEnquiry.id);
    } catch (dbError: any) {
      console.log(`❌ [${requestId}] DATABASE ERROR:`, dbError.message);
      console.log(`❌ [${requestId}] Error code:`, dbError.code);
      console.log(`❌ [${requestId}] Error detail:`, dbError.detail);
      console.log(`❌ [${requestId}] Error stack:`, dbError.stack);
      
      // Try to continue and return error info
      return res.status(500).json({
        success: false,
        error: 'Database error',
        dbError: {
          message: dbError.message,
          code: dbError.code,
          detail: dbError.detail
        },
        enquiry,
        requestId
      });
    }
    
    const processingTime = Date.now() - startTime;
    console.log(`📧 [${requestId}] === WEBHOOK SUCCESS ===`);
    console.log(`📧 [${requestId}] Processing time: ${processingTime}ms`);
    
    res.status(200).json({
      success: true,
      enquiryId: newEnquiry.id,
      clientName,
      clientEmail,
      processingTime: `${processingTime}ms`,
      debug: {
        emailExtractionMethod,
        nameExtractionMethod,
        validation
      },
      requestId
    });
    
  } catch (error: any) {
    const processingTime = Date.now() - startTime;
    console.log(`❌ [${requestId}] === WEBHOOK ERROR ===`);
    console.log(`❌ [${requestId}] Error type:`, typeof error);
    console.log(`❌ [${requestId}] Error name:`, error.name);
    console.log(`❌ [${requestId}] Error message:`, error.message);
    console.log(`❌ [${requestId}] Error stack:`, error.stack);
    console.log(`❌ [${requestId}] Processing time: ${processingTime}ms`);
    
    res.status(500).json({
      success: false,
      error: error.message,
      errorType: error.name,
      processingTime: `${processingTime}ms`,
      requestId
    });
  }
});
```

## What This Will Reveal

This debugging version will show exactly:

1. **What data Mailgun sends** for `timfulkermusic@gmail.com`
2. **Where the processing fails** (regex, validation, database)
3. **The exact error message** if any step throws an exception
4. **Field extraction results** for problematic emails

## Expected Findings

Based on the silent failure pattern, I suspect:

1. **Email regex failure** - the original regex might not match the email format
2. **Validation failure** - some field might be empty/invalid
3. **Silent database exception** - the error isn't being caught properly

## Next Steps

1. **Deploy this debugging version**
2. **Send a test email** from `timfulkermusic@gmail.com`
3. **Check the logs** for the specific failure point
4. **Apply the targeted fix** based on what the logs reveal

The logs will show exactly where and why the webhook is failing for this specific email address.